<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Isometric City Destruction Game</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        .ui-container { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial; }
        .control-panel { position: absolute; top: 50px; left: 10px; background: rgba(0, 0, 0, 0.7); padding: 10px; }
        .control-panel input { width: 60px; margin-right: 10px; }
        .control-panel button { margin-top: 5px; }
        .camera-controls { position: absolute; top: 150px; left: 10px; background: rgba(0, 0, 0, 0.7); padding: 10px; color: white; }
        .camera-controls input { width: 100px; }
    </style>
</head>
<body>
    <div class="ui-container">
        <div id="score">Score: 0</div>
        <div id="time">Time: 60</div>
    </div>
    <div class="control-panel">
        <label>Map Size: <input type="number" id="mapSize" value="50" min="10" max="100"></label><br>
        <label>Buildings: <input type="number" id="numBuildings" value="20" min="10" max="100"></label><br>
        <button id="regenerate">Regenerate Map</button>
    </div>
    <div class="camera-controls">
        <label>X: <input type="range" id="camX" min="-50" max="50" value="0"></label><br>
        <label>Y: <input type="range" id="camY" min="10" max="50" value="25"></label><br>
        <label>Z: <input type="range" id="camZ" min="-50" max="50" value="0"></label>
    </div>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const aspect = window.innerWidth / window.innerHeight;
        const frustumSize = 30;
        const camera = new THREE.OrthographicCamera(
            frustumSize * aspect / -2,
            frustumSize * aspect / 2,
            frustumSize / 2,
            frustumSize / -2,
            0.1,
            1000
        );
        camera.rotation.order = 'YXZ';
        camera.rotation.y = Math.PI / 4;
        camera.rotation.x = Math.atan(1 / Math.sqrt(2));

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // Grid
        let gridSize = 50;
        let gridHelper;
        let grid = [];

        function createGrid(size) {
            if (gridHelper) scene.remove(gridHelper);
            gridHelper = new THREE.GridHelper(size, size, 0x333333, 0x333333);
            gridHelper.position.set(size / 2 - 0.5, 0, size / 2 - 0.5);
            scene.add(gridHelper);
            grid = Array.from({ length: size }, () => Array(size).fill(null));
        }

        // Base Building class
        class Building {
            constructor(x, z, w, d, height, maxHP, modelPaths) {
                this.x = x;
                this.z = z;
                this.w = w;
                this.d = d;
                this.height = height;
                this.maxHP = maxHP;
                this.currentHP = maxHP;
                this.healthBar = null;
                this.modelPaths = modelPaths || [
                    'models/building_full.glb',
                    'models/building_damaged.glb',
                    'models/building_critical.glb'
                ];

                this.updateModel();
                this.box = new THREE.Box3(
                    new THREE.Vector3(x, 0, z),
                    new THREE.Vector3(x + w, height, z + d)
                );
            }

            updateModel() {
                if (this.mesh) scene.remove(this.mesh);
                const hpPercent = (this.currentHP / this.maxHP) * 100;
                const modelPath = hpPercent >= 60 ? this.modelPaths[0] :
                                 hpPercent >= 30 ? this.modelPaths[1] : this.modelPaths[2];

                const loader = new THREE.GLTFLoader();
                loader.load(
                    modelPath,
                    (gltf) => {
                        if (this.mesh) scene.remove(this.mesh);
                        this.mesh = gltf.scene;
                        this.mesh.position.set(this.x + this.w / 2, 0, this.z + this.d / 2);
                        this.mesh.scale.set(this.w, this.height, this.d);
                        this.mesh.traverse(child => {
                            if (child.isMesh) {
                                child.material = new THREE.MeshLambertMaterial({
                                    color: 0x808080,
                                    transparent: true,
                                    opacity: 1
                                });
                            }
                        });
                        scene.add(this.mesh);
                    },
                    undefined,
                    (error) => {
                        console.error(`Failed to load ${modelPath}:`, error);
                        const geometry = new THREE.BoxGeometry(this.w, this.height, this.d);
                        const material = new THREE.MeshLambertMaterial({
                            color: 0x808080,
                            transparent: true,
                            opacity: 1
                        });
                        this.mesh = new THREE.Mesh(geometry, material);
                        this.mesh.position.set(this.x + this.w / 2, this.height / 2, this.z + this.d / 2);
                        scene.add(this.mesh);
                    }
                );
            }

            updateTransparency(playerPos) {
                const playerBehind = playerPos.z > this.z + this.d;
                if (this.mesh) {
                    this.mesh.traverse(child => {
                        if (child.isMesh) child.material.opacity = playerBehind ? 0.5 : 1; // Adjust transparency here (0.5 = 50% transparent)
                    });
                }
            }
        }

        // Building subclasses
        class House1 extends Building {
            constructor(x, z) {
                super(x, z, 1, 1, 1, 3, [
                    'models/house1_full.glb',
                    'models/house1_damaged.glb',
                    'models/house1_critical.glb'
                ]);
            }
        }

        class House2 extends Building {
            constructor(x, z) {
                super(x, z, 1, 1, 2, 6, [
                    'models/house2_full.glb',
                    'models/house2_damaged.glb',
                    'models/house2_critical.glb'
                ]);
            }
        }

        class Shop1 extends Building {
            constructor(x, z, w, d, h) {
                super(x, z, w, d, h, w * d * 3, [
                    'models/shop1_full.glb',
                    'models/shop1_damaged.glb',
                    'models/shop1_critical.glb'
                ]);
            }
        }

        class Shop2 extends Building {
            constructor(x, z, w, d, h) {
                super(x, z, w, d, h, w * d * 3, [
                    'models/shop2_full.glb',
                    'models/shop2_damaged.glb',
                    'models/shop2_critical.glb'
                ]);
            }
        }

        class Office1 extends Building {
            constructor(x, z, w, d, h) {
                super(x, z, w, d, h, w * d * 3, [
                    'models/office1_full.glb',
                    'models/office1_damaged.glb',
                    'models/office1_critical.glb'
                ]);
            }
        }

        let buildings = [];
        generateBuildings(20, gridSize);

        function generateBuildings(numBuildings, size) {
            buildings.forEach(b => {
                scene.remove(b.mesh);
                if (b.healthBar) scene.remove(b.healthBar);
            });
            buildings = [];
            createGrid(size);

            const buildingTypes = [
                { type: House1, sizes: [[1, 1, 1]] },
                { type: House2, sizes: [[1, 1, 2]] },
                { type: Shop1, sizes: [[1, 2, 2], [2, 1, 2], [2, 2, 2]] },
                { type: Shop2, sizes: [[1, 2, 2], [2, 1, 2], [2, 2, 2]] },
                { type: Office1, sizes: [[3, 3, 8], [4, 4, 10], [3, 2, 6], [2, 3, 6]] }
            ];

            let attempts = 0;
            while (buildings.length < numBuildings && attempts < 10000) {
                const buildingType = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                const [w, d, h] = buildingType.sizes[Math.floor(Math.random() * buildingType.sizes.length)];
                const x = Math.floor(Math.random() * (size - w));
                const z = Math.floor(Math.random() * (size - d));
                let free = true;
                for (let i = z; i < z + d && i < size; i++) {
                    for (let j = x; j < x + w && j < size; j++) {
                        if (grid[i][j]) free = false;
                    }
                }
                if (free) {
                    const building = new buildingType.type(x, z, w, d, h);
                    buildings.push(building);
                    for (let i = z; i < z + d; i++) {
                        for (let j = x; j < x + w; j++) {
                            grid[i][j] = building;
                        }
                    }
                }
                attempts++;
            }
        }

        // Player class
        class Player {
            constructor() {
                this.x = 0;
                this.z = 0;
                this.speed = 5;
                this.direction = new THREE.Vector3(0, 0, 0);
                this.lastDirection = new THREE.Vector3(1, 0, 0);

                this.loadModel();
            }

            loadModel() {
                const loader = new THREE.GLTFLoader();
                loader.load(
                    'models/character.glb', // Replace with your actual player model path
                    (gltf) => {
                        this.mesh = gltf.scene;
                        this.mesh.position.set(this.x, 0, this.z);
                        this.mesh.scale.set(0.5, 0.5, 0.5); // Adjust scale as needed
                        scene.add(this.mesh);

                        const arrowGeometry = new THREE.ConeGeometry(0.2, 0.5, 8);
                        const arrowMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                        this.arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
                        this.arrow.position.set(this.x, 1, this.z);
                        this.arrow.rotation.x = Math.PI / 2;
                        scene.add(this.arrow);
                    },
                    undefined,
                    (error) => {
                        console.error('Failed to load player model:', error);
                        const geometry = new THREE.CylinderGeometry(0.3, 0.3, 1, 16);
                        const material = new THREE.MeshLambertMaterial({ color: 0x0000ff });
                        this.mesh = new THREE.Mesh(geometry, material);
                        this.mesh.position.set(this.x, 0.5, this.z);
                        scene.add(this.mesh);

                        const arrowGeometry = new THREE.ConeGeometry(0.2, 0.5, 8);
                        const arrowMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                        this.arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
                        this.arrow.position.set(this.x, 1, this.z);
                        this.arrow.rotation.x = Math.PI / 2;
                        scene.add(this.arrow);
                    }
                );
            }

            update(delta) {
                const moveDir = new THREE.Vector3(this.direction.x, 0, this.direction.z).normalize();
                const isoX = (moveDir.x - moveDir.z) * 0.7071;
                const isoZ = (moveDir.x + moveDir.z) * 0.7071;

                const dx = isoX * this.speed * delta;
                const dz = isoZ * this.speed * delta;

                const newX = Math.max(0, Math.min(gridSize - 0.5, this.x + dx));
                const newZ = Math.max(0, Math.min(gridSize - 0.5, this.z + dz));

                if (this.canMove(newX, this.z)) this.x = newX;
                if (this.canMove(this.x, newZ)) this.z = newZ;

                this.mesh.position.set(this.x, this.mesh.position.y, this.z);
                this.arrow.position.set(this.x, this.mesh.position.y + 1, this.z);

                if (this.direction.length() > 0) {
                    this.lastDirection.set(isoX, 0, isoZ).normalize();
                    const angle = Math.atan2(this.lastDirection.z, this.lastDirection.x) - Math.PI / 2;
                    this.arrow.rotation.z = angle;
                }
            }

            canMove(x, z) {
                const playerBox = new THREE.Box3(
                    new THREE.Vector3(x - 0.25, 0, z - 0.25),
                    new THREE.Vector3(x + 0.25, 1, z + 0.25)
                );
                return !buildings.some(b => playerBox.intersectsBox(b.box));
            }
        }

        let player = new Player();

        // Game state
        let score = 0;
        let time = 60;
        let gameOver = false;
        let canHit = true;
        const scoreElement = document.getElementById('score');
        const timeElement = document.getElementById('time');

        // Keyboard controls
        const pressedKeys = new Set();
        document.addEventListener('keydown', (e) => {
            if (gameOver) return;
            pressedKeys.add(e.key.toLowerCase());
            if (e.key === ' ' && canHit) {
                hitBuilding();
                canHit = false;
            }
        });
        document.addEventListener('keyup', (e) => {
            pressedKeys.delete(e.key.toLowerCase());
            if (e.key === ' ') canHit = true;
        });

        function updatePlayerDirection() {
            player.direction.set(0, 0, 0);
            if (pressedKeys.has('w') || pressedKeys.has('arrowup')) player.direction.x = -1;
            if (pressedKeys.has('s') || pressedKeys.has('arrowdown')) player.direction.x = 1;
            if (pressedKeys.has('a') || pressedKeys.has('arrowleft')) player.direction.z = 1;
            if (pressedKeys.has('d') || pressedKeys.has('arrowright')) player.direction.z = -1;
            if (player.direction.length() > 0) player.direction.normalize();
        }

        // Hit building
        function hitBuilding() {
            const raycaster = new THREE.Raycaster();
            raycaster.set(player.mesh.position, player.lastDirection);
            const intersects = raycaster.intersectObjects(buildings.map(b => b.mesh));
            if (intersects.length > 0) {
                const building = buildings.find(b => b.mesh === intersects[0].object);
                if (building) {
                    building.currentHP -= 1;
                    score += 1;
                    scoreElement.textContent = `Score: ${score}`;
                    building.updateModel();

                    if (building.currentHP <= 0) {
                        scene.remove(building.mesh);
                        if (building.healthBar) scene.remove(building.healthBar);
                        for (let i = building.z; i < building.z + building.d; i++) {
                            for (let j = building.x; j < building.x + building.w; j++) {
                                grid[i][j] = null;
                            }
                        }
                        buildings = buildings.filter(b => b !== building);
                    } else {
                        if (!building.healthBar) {
                            const canvas = document.createElement('canvas');
                            canvas.width = 100;
                            canvas.height = 20;
                            building.healthCanvas = canvas;
                            const texture = new THREE.CanvasTexture(canvas);
                            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                            building.healthBar = new THREE.Sprite(spriteMaterial);
                            building.healthBar.position.set(
                                building.mesh.position.x,
                                building.height + 0.5,
                                building.mesh.position.z
                            );
                            building.healthBar.scale.set(2, 0.4, 1);
                            scene.add(building.healthBar);
                        }
                        const ctx = building.healthCanvas.getContext('2d');
                        ctx.clearRect(0, 0, 100, 20);
                        ctx.fillStyle = 'red';
                        ctx.fillRect(0, 0, 100, 20);
                        const healthWidth = 100 * (building.currentHP / building.maxHP);
                        ctx.fillStyle = 'green';
                        ctx.fillRect(0, 0, healthWidth, 20);
                        building.healthBar.material.map.needsUpdate = true;
                    }
                }
            }
        }

        // UI controls
        document.getElementById('regenerate').addEventListener('click', () => {
            const newGridSize = parseInt(document.getElementById('mapSize').value);
            const newNumBuildings = parseInt(document.getElementById('numBuildings').value);
            gridSize = Math.min(Math.max(newGridSize, 10), 100);
            generateBuildings(Math.min(Math.max(newNumBuildings, 10), 100), gridSize);
            player.x = 0;
            player.z = 0;
            player.mesh.position.set(0, player.mesh.position.y, 0);
            player.arrow.position.set(0, player.mesh.position.y + 1, 0);
            score = 0;
            time = 60;
            gameOver = false;
            scoreElement.textContent = `Score: ${score}`;
            timeElement.textContent = `Time: ${Math.ceil(time)}`;
        });

        // Camera controls
        const camXInput = document.getElementById('camX');
        const camYInput = document.getElementById('camY');
        const camZInput = document.getElementById('camZ');
        function updateCamera() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
        }
        camXInput.addEventListener('input', updateCamera);
        camYInput.addEventListener('input', updateCamera);
        camZInput.addEventListener('input', updateCamera);

        // Game loop
        let lastTime = performance.now();
        function animate() {
            requestAnimationFrame(animate);
            if (!gameOver) {
                const currentTime = performance.now();
                const delta = (currentTime - lastTime) / 1000;
                lastTime = currentTime;

                updatePlayerDirection();
                player.update(delta);

                const camOffsetX = parseInt(camXInput.value);
                const camOffsetY = parseInt(camYInput.value);
                const camOffsetZ = parseInt(camZInput.value);
                camera.position.set(player.x + camOffsetX + 25, camOffsetY, player.z + camOffsetZ + 25);

                buildings.forEach(building => building.updateTransparency(player.mesh.position));

                time -= delta;
                if (time <= 0) {
                    gameOver = true;
                    time = 0;
                    alert(`Game Over! Final Score: ${score}`);
                }
                timeElement.textContent = `Time: ${Math.ceil(time)}`;
            }
            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            camera.left = frustumSize * width / height / -2;
            camera.right = frustumSize * width / height / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });
    </script>
</body>
</html>
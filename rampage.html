<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Isometric City Destruction Game</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
<<<<<<< HEAD
=======
    <!-- Removed GLTFLoader since we're not using models anymore -->
>>>>>>> 6e3921e1cc1b4a0b4dbb5d7cfaa47d7c61ed1162
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        .ui-container { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial; }
        .control-panel { position: absolute; top: 50px; left: 10px; background: rgba(0, 0, 0, 0.7); padding: 10px; }
        .control-panel input { width: 60px; margin-right: 10px; }
        .control-panel button { margin-top: 5px; }
        .camera-controls { position: absolute; top: 150px; left: 10px; background: rgba(0, 0, 0, 0.7); padding: 10px; color: white; }
        .camera-controls input { width: 100px; }
    </style>
</head>
<body>
    <div class="ui-container">
        <div id="score">Score: 0</div>
        <div id="time">Time: 60</div>
    </div>
    <div class="control-panel">
        <label>Map Size: <input type="number" id="mapSize" value="40" min="10" max="100"></label><br>
        <label>Buildings: <input type="number" id="numBuildings" value="20" min="10" max="100"></label><br>
        <button id="regenerate">Regenerate Map</button>
    </div>
    <div class="camera-controls">
        <label>X: <input type="range" id="camX" min="-50" max="50" value="0"></label><br>
        <label>Y: <input type="range" id="camY" min="10" max="50" value="25"></label><br>
        <label>Z: <input type="range" id="camZ" min="-50" max="50" value="0"></label>
    </div>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const aspect = window.innerWidth / window.innerHeight;
        const frustumSize = 30; // Increased from 30 to ensure the entire scene is visible
        const camera = new THREE.OrthographicCamera(
            frustumSize * aspect / -2,
            frustumSize * aspect / 2,
            frustumSize / 2,
            frustumSize / -2,
            0.1,
            1000
        );
        camera.rotation.order = 'YXZ';
        camera.rotation.y = Math.PI / 4;
        camera.rotation.x = Math.atan(1 / Math.sqrt(2));
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // Grid
        let gridSize = 50;
        let gridHelper;
        let grid = [];

        function createGrid(size) {
            if (gridHelper) scene.remove(gridHelper);
            gridHelper = new THREE.GridHelper(size, size, 0x333333, 0x333333);
            gridHelper.position.set(size / 2 - 0.5, 0, size / 2 - 0.5);
            scene.add(gridHelper);
            grid = Array.from({ length: size }, () => Array(size).fill(null));
        }

        // Base Building class
        class Building {
<<<<<<< HEAD
            constructor(x, z, w, d, height, maxHP, texturePaths, fallbackColor) {
=======
            constructor(x, z, w, d, height, maxHP) {
>>>>>>> 6e3921e1cc1b4a0b4dbb5d7cfaa47d7c61ed1162
                this.x = x;
                this.z = z;
                this.w = w;
                this.d = d;
                this.height = height;
                this.maxHP = maxHP;
                this.currentHP = maxHP;
                this.healthBar = null;
<<<<<<< HEAD
                this.texturePaths = texturePaths || {
                    full: 'textures/building_full.jpg',
                    damaged: 'textures/building_damaged.jpg',
                    critical: 'textures/building_critical.jpg'
                };
                this.fallbackColor = fallbackColor || 0x808080;
=======
>>>>>>> 6e3921e1cc1b4a0b4dbb5d7cfaa47d7c61ed1162

                this.updateModel();
                this.box = new THREE.Box3(
                    new THREE.Vector3(x, 0, z),
                    new THREE.Vector3(x + w, height, z + d)
                );
            }

            updateModel() {
                if (this.mesh) scene.remove(this.mesh);
<<<<<<< HEAD
                if (this.currentHP <= 0) return; // Skip mesh creation if HP is 0

                const hpPercent = (this.currentHP / this.maxHP) * 100;
                const texturePath = hpPercent >= 60 ? this.texturePaths.full :
                                    hpPercent >= 30 ? this.texturePaths.damaged : this.texturePaths.critical;

                const loader = new THREE.TextureLoader();
                loader.load(
                    texturePath,
                    (texture) => {
                        if (this.currentHP <= 0) return; // Avoid adding mesh if destroyed during load
                        const material = new THREE.MeshLambertMaterial({
                            map: texture,
                            transparent: true,
                            opacity: 1
                        });
                        this.mesh = new THREE.Mesh(new THREE.BoxGeometry(this.w, this.height, this.d), material);
                        this.mesh.position.set(this.x + this.w / 2, this.height / 2, this.z + this.d / 2);
                        scene.add(this.mesh);
                    },
                    undefined,
                    (error) => {
                        console.error(`Failed to load texture ${texturePath}:`, error);
                        if (this.currentHP <= 0) return; // Avoid adding mesh if destroyed during load
                        const material = new THREE.MeshLambertMaterial({
                            color: this.fallbackColor,
                            transparent: true,
                            opacity: 1
                        });
                        this.mesh = new THREE.Mesh(new THREE.BoxGeometry(this.w, this.height, this.d), material);
                        this.mesh.position.set(this.x + this.w / 2, this.height / 2, this.z + this.d / 2);
                        scene.add(this.mesh);
                    }
                );
=======
                const hpPercent = (this.currentHP / this.maxHP) * 100;

                let baseColor;
                if (this instanceof House1 || this instanceof House2) {
                    baseColor = 0xff0000; // Red for houses
                } else if (this instanceof Shop1 || this instanceof Shop2) {
                    baseColor = 0x00ff00; // Green for shops
                } else if (this instanceof Office1) {
                    baseColor = 0x0000ff; // Blue for offices
                }

                // Adjust color based on health
                const color = hpPercent >= 60 ? baseColor :
                              hpPercent >= 30 ? (baseColor & 0xfefefe) >> 1 : (baseColor & 0xfefefe) >> 2;

                this.mesh = new THREE.Group();

                if (this instanceof House1 || this instanceof House2) {
                    // Base box for house
                    const baseGeometry = new THREE.BoxGeometry(this.w, this.height - 0.5, this.d);
                    const baseMaterial = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 1 });
                    const baseMesh = new THREE.Mesh(baseGeometry, baseMaterial);
                    baseMesh.position.set(0, (this.height - 0.5) / 2, 0);
                    this.mesh.add(baseMesh);

                    // Roof cone for house
                    const roofGeometry = new THREE.ConeGeometry(this.w * 0.7, 0.5, 4);
                    const roofMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513, transparent: true, opacity: 1 }); // Brown roof
                    const roofMesh = new THREE.Mesh(roofGeometry, roofMaterial);
                    roofMesh.position.set(0, this.height - 0.25, 0);
                    roofMesh.rotation.y = Math.PI / 4; // Rotate to align with isometric view
                    this.mesh.add(roofMesh);
                } else {
                    // Simple box for shops and offices
                    const geometry = new THREE.BoxGeometry(this.w, this.height, this.d);
                    const material = new THREE.MeshLambertMaterial({ color: color, transparent: true, opacity: 1 });
                    const boxMesh = new THREE.Mesh(geometry, material);
                    boxMesh.position.set(0, this.height / 2, 0);
                    this.mesh.add(boxMesh);
                }

                this.mesh.position.set(this.x + this.w / 2, 0, this.z + this.d / 2);
                scene.add(this.mesh);
>>>>>>> 6e3921e1cc1b4a0b4dbb5d7cfaa47d7c61ed1162
            }

            updateTransparency(playerPos) {
                const playerBehind = playerPos.z > this.z + this.d;
                if (this.mesh) {
                    this.mesh.traverse(child => {
                        if (child.isMesh) child.material.opacity = playerBehind ? 0.5 : 1;
                    });
                }
            }
        }

        // Building subclasses
        class House1 extends Building {
            constructor(x, z) {
<<<<<<< HEAD
                super(x, z, 1, 1, 1, 3, {
                    full: 'textures/house1_full.jpg',
                    damaged: 'textures/house1_damaged.jpg',
                    critical: 'textures/house1_critical.jpg'
                }, 0xff0000);
=======
                super(x, z, 1, 1, 1, 3);
>>>>>>> 6e3921e1cc1b4a0b4dbb5d7cfaa47d7c61ed1162
            }
        }

        class House2 extends Building {
            constructor(x, z) {
<<<<<<< HEAD
                super(x, z, 1, 1, 2, 6, {
                    full: 'textures/house2_full.jpg',
                    damaged: 'textures/house2_damaged.jpg',
                    critical: 'textures/house2_critical.jpg'
                }, 0xff0000);
=======
                super(x, z, 1, 1, 2, 6);
>>>>>>> 6e3921e1cc1b4a0b4dbb5d7cfaa47d7c61ed1162
            }
        }

        class Shop1 extends Building {
            constructor(x, z, w, d, h) {
<<<<<<< HEAD
                super(x, z, w, d, h, w * d * 3, {
                    full: 'textures/shop1_full.jpg',
                    damaged: 'textures/shop1_damaged.jpg',
                    critical: 'textures/shop1_critical.jpg'
                }, 0x00ff00);
=======
                super(x, z, w, d, h, w * d * 3);
>>>>>>> 6e3921e1cc1b4a0b4dbb5d7cfaa47d7c61ed1162
            }
        }

        class Shop2 extends Building {
            constructor(x, z, w, d, h) {
<<<<<<< HEAD
                super(x, z, w, d, h, w * d * 3, {
                    full: 'textures/shop2_full.jpg',
                    damaged: 'textures/shop2_damaged.jpg',
                    critical: 'textures/shop2_critical.jpg'
                }, 0x00ff00);
=======
                super(x, z, w, d, h, w * d * 3);
>>>>>>> 6e3921e1cc1b4a0b4dbb5d7cfaa47d7c61ed1162
            }
        }

        class Office1 extends Building {
            constructor(x, z, w, d, h) {
<<<<<<< HEAD
                super(x, z, w, d, h, w * d * 3, {
                    full: 'textures/office1_full.jpg',
                    damaged: 'textures/office1_damaged.jpg',
                    critical: 'textures/office1_critical.jpg'
                }, 0x0000ff);
=======
                super(x, z, w, d, h, w * d * 3);
>>>>>>> 6e3921e1cc1b4a0b4dbb5d7cfaa47d7c61ed1162
            }
        }

        let buildings = [];
        generateBuildings(20, gridSize);

        function generateBuildings(numBuildings, size) {
            buildings.forEach(b => {
                scene.remove(b.mesh);
                if (b.healthBar) scene.remove(b.healthBar);
            });
            buildings = [];
            createGrid(size);

            const buildingTypes = [
                { type: House1, sizes: [[1, 1, 1]] },
                { type: House2, sizes: [[1, 1, 2]] },
                { type: Shop1, sizes: [[1, 2, 2], [2, 1, 2], [2, 2, 2]] },
                { type: Shop2, sizes: [[1, 2, 2], [2, 1, 2], [2, 2, 2]] },
                { type: Office1, sizes: [[3, 3, 8], [4, 4, 10], [3, 2, 6], [2, 3, 6]] }
            ];

            let attempts = 0;
            while (buildings.length < numBuildings && attempts < 10000) {
                const buildingType = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                const [w, d, h] = buildingType.sizes[Math.floor(Math.random() * buildingType.sizes.length)];
                const x = Math.floor(Math.random() * (size - w));
                const z = Math.floor(Math.random() * (size - d));
                let free = true;
                for (let i = z; i < z + d && i < size; i++) {
                    for (let j = x; j < x + w && j < size; j++) {
                        if (grid[i][j]) free = false;
                    }
                }
                if (free) {
                    const building = new buildingType.type(x, z, w, d, h);
                    buildings.push(building);
                    for (let i = z; i < z + d; i++) {
                        for (let j = x; j < x + w; j++) {
                            grid[i][j] = building;
                        }
                    }
                }
                attempts++;
            }
        }

        // Player class
        class Player {
            constructor() {
                this.x = 0;
                this.z = 0;
                this.speed = 5;
                this.direction = new THREE.Vector3(0, 0, 0);
                this.lastDirection = new THREE.Vector3(1, 0, 0);

<<<<<<< HEAD
                const geometry = new THREE.CylinderGeometry(0.3, 0.3, 1, 16);
                const material = new THREE.MeshLambertMaterial({ color: 0x0000ff });
=======
                // Use cylinder as the player mesh
                const geometry = new THREE.CylinderGeometry(0.3, 0.3, 1, 16);
                const material = new THREE.MeshLambertMaterial({ color: 0x0000ff }); // Blue cylinder
>>>>>>> 6e3921e1cc1b4a0b4dbb5d7cfaa47d7c61ed1162
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.set(this.x, 0.5, this.z);
                scene.add(this.mesh);

                const arrowGeometry = new THREE.ConeGeometry(0.2, 0.5, 8);
                const arrowMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                this.arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
                this.arrow.position.set(this.x, 1, this.z);
                this.arrow.rotation.x = Math.PI / 2;
                scene.add(this.arrow);
<<<<<<< HEAD
=======

                // Removed loadModel() call
>>>>>>> 6e3921e1cc1b4a0b4dbb5d7cfaa47d7c61ed1162
            }

            update(delta) {
                const moveDir = new THREE.Vector3(this.direction.x, 0, this.direction.z).normalize();
                const isoX = (moveDir.x - moveDir.z) * 0.7071;
                const isoZ = (moveDir.x + moveDir.z) * 0.7071;

                const dx = isoX * this.speed * delta;
                const dz = isoZ * this.speed * delta;

                const newX = Math.max(0, Math.min(gridSize - 0.5, this.x + dx));
                const newZ = Math.max(0, Math.min(gridSize - 0.5, this.z + dz));

                if (this.canMove(newX, this.z)) this.x = newX;
                if (this.canMove(this.x, newZ)) this.z = newZ;

                this.mesh.position.set(this.x, 0.5, this.z);
                this.arrow.position.set(this.x, 1, this.z);

                if (this.direction.length() > 0) {
                    this.lastDirection.set(isoX, 0, isoZ).normalize();
                    const angle = Math.atan2(this.lastDirection.z, this.lastDirection.x) - Math.PI / 2;
                    this.arrow.rotation.z = angle;
                }
            }

            canMove(x, z) {
                const playerBox = new THREE.Box3(
                    new THREE.Vector3(x - 0.25, 0, z - 0.25),
                    new THREE.Vector3(x + 0.25, 1, z + 0.25)
                );
                return !buildings.some(b => playerBox.intersectsBox(b.box));
            }
        }

        let player = new Player();

        // Game state
        let score = 0;
        let time = 60;
        let gameOver = false;
        let canHit = true;
        const scoreElement = document.getElementById('score');
        const timeElement = document.getElementById('time');

        // Keyboard controls
        const pressedKeys = new Set();
        document.addEventListener('keydown', (e) => {
            if (gameOver) return;
            pressedKeys.add(e.key.toLowerCase());
            if (e.key === ' ' && canHit) {
                hitBuilding();
                canHit = false;
            }
        });
        document.addEventListener('keyup', (e) => {
            pressedKeys.delete(e.key.toLowerCase());
            if (e.key === ' ') canHit = true;
        });

        function updatePlayerDirection() {
            player.direction.set(0, 0, 0);
            if (pressedKeys.has('w') || pressedKeys.has('arrowup')) player.direction.x = -1;
            if (pressedKeys.has('s') || pressedKeys.has('arrowdown')) player.direction.x = 1;
            if (pressedKeys.has('a') || pressedKeys.has('arrowleft')) player.direction.z = 1;
            if (pressedKeys.has('d') || pressedKeys.has('arrowright')) player.direction.z = -1;
            if (player.direction.length() > 0) player.direction.normalize();
        }

        // Hit building with proper removal
        function hitBuilding() {
            const raycaster = new THREE.Raycaster();
            raycaster.set(player.mesh.position, player.lastDirection);
            const intersects = raycaster.intersectObjects(buildings.map(b => b.mesh));
            if (intersects.length > 0) {
                const intersect = intersects[0];
                const building = buildings.find(b => b.mesh === intersect.object);
                if (building) {
                    const distanceToBuilding = building.box.distanceToPoint(player.mesh.position);
                    if (distanceToBuilding <= 1) {
                        building.currentHP -= 1;
                        score += 1;
                        scoreElement.textContent = `Score: ${score}`;

                        if (building.currentHP <= 0) {
                            // Ensure mesh and health bar are removed immediately
                            if (building.mesh) {
                                scene.remove(building.mesh);
                                building.mesh = null; // Clear reference
                            }
                            if (building.healthBar) {
                                scene.remove(building.healthBar);
                                building.healthBar = null; // Clear reference
                            }
                            for (let i = building.z; i < building.z + building.d; i++) {
                                for (let j = building.x; j < building.x + building.w; j++) {
                                    grid[i][j] = null;
                                }
                            }
                            buildings = buildings.filter(b => b !== building);
                        } else {
                            building.updateModel();

                            // Update health bar
                            if (!building.healthBar) {
                                const canvas = document.createElement('canvas');
                                canvas.width = 100;
                                canvas.height = 20;
                                building.healthCanvas = canvas;
                                const texture = new THREE.CanvasTexture(canvas);
                                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                                building.healthBar = new THREE.Sprite(spriteMaterial);
                                building.healthBar.position.set(
                                    building.mesh.position.x,
                                    building.height + 0.5,
                                    building.mesh.position.z
                                );
                                building.healthBar.scale.set(2, 0.4, 1);
                                scene.add(building.healthBar);
                            }
                            const ctx = building.healthCanvas.getContext('2d');
                            ctx.clearRect(0, 0, 100, 20);
                            ctx.fillStyle = 'red';
                            ctx.fillRect(0, 0, 100, 20);
                            const healthWidth = 100 * (building.currentHP / building.maxHP);
                            ctx.fillStyle = 'green';
                            ctx.fillRect(0, 0, healthWidth, 20);
                            building.healthBar.material.map.needsUpdate = true;
                        }
                    }
                }
            }
        }

        // UI controls
        document.getElementById('regenerate').addEventListener('click', () => {
            const newGridSize = parseInt(document.getElementById('mapSize').value);
            const newNumBuildings = parseInt(document.getElementById('numBuildings').value);
            gridSize = Math.min(Math.max(newGridSize, 10), 100);
            generateBuildings(Math.min(Math.max(newNumBuildings, 10), 100), gridSize);
            player.x = 0;
            player.z = 0;
            player.mesh.position.set(0, 0.5, 0);
            player.arrow.position.set(0, 1, 0);
            score = 0;
            time = 60;
            gameOver = false;
            scoreElement.textContent = `Score: ${score}`;
            timeElement.textContent = `Time: ${Math.ceil(time)}`;
        });

        // Camera controls
        const camXInput = document.getElementById('camX');
        const camYInput = document.getElementById('camY');
        const camZInput = document.getElementById('camZ');
        function updateCamera() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
        }
        camXInput.addEventListener('input', updateCamera);
        camYInput.addEventListener('input', updateCamera);
        camZInput.addEventListener('input', updateCamera);

        // Game loop
        let lastTime = performance.now();
        function animate() {
            requestAnimationFrame(animate);
            if (!gameOver) {
                const currentTime = performance.now();
                const delta = (currentTime - lastTime) / 1000;
                lastTime = currentTime;

                updatePlayerDirection();
                player.update(delta);

                const camOffsetX = parseInt(camXInput.value);
                const camOffsetY = parseInt(camYInput.value);
                const camOffsetZ = parseInt(camZInput.value);
                camera.position.set(player.x + camOffsetX + 25, camOffsetY, player.z + camOffsetZ + 25);
<<<<<<< HEAD
                camera.lookAt(player.x, 0, player.z);
=======
                camera.lookAt(player.x, 0, player.z); // Ensure camera follows player
>>>>>>> 6e3921e1cc1b4a0b4dbb5d7cfaa47d7c61ed1162

                buildings.forEach(building => building.updateTransparency(player.mesh.position));

                time -= delta;
                if (time <= 0) {
                    gameOver = true;
                    time = 0;
                    alert(`Game Over! Final Score: ${score}`);
                }
                timeElement.textContent = `Time: ${Math.ceil(time)}`;
            }
            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            camera.left = frustumSize * width / height / -2;
            camera.right = frustumSize * width / height / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });
    </script>
</body>
</html>

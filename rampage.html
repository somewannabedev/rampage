<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Isometric City Destruction Game</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        .ui-container { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial; }
        .control-panel { position: absolute; top: 50px; left: 10px; background: rgba(0, 0, 0, 0.7); padding: 10px; }
        .control-panel input { width: 60px; margin-right: 10px; }
        .control-panel button { margin-top: 5px; }
        .camera-controls { position: absolute; top: 150px; left: 10px; background: rgba(0, 0, 0, 0.7); padding: 10px; color: white; }
        .camera-controls input { width: 100px; }
    </style>
</head>
<body>
    <div class="ui-container">
        <div id="score">Score: 0</div>
        <div id="time">Time: 60</div>
    </div>
    <div class="control-panel">
        <label>Map Size: <input type="number" id="mapSize" value="40" min="10" max="100"></label><br>
        <label>Buildings: <input type="number" id="numBuildings" value="20" min="10" max="100"></label><br>
        <button id="regenerate">Regenerate Map</button>
    </div>
    <div class="camera-controls">
        <label>X: <input type="range" id="camX" min="-50" max="50" value="0"></label><br>
        <label>Y: <input type="range" id="camY" min="10" max="50" value="25"></label><br>
        <label>Z: <input type="range" id="camZ" min="-50" max="50" value="0"></label>
    </div>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const aspect = window.innerWidth / window.innerHeight;
        const frustumSize = 30;
        const camera = new THREE.OrthographicCamera(
            frustumSize * aspect / -2,
            frustumSize * aspect / 2,
            frustumSize / 2,
            frustumSize / -2,
            0.1,
            1000
        );
        camera.rotation.order = 'YXZ';
        camera.rotation.y = Math.PI / 4;
        camera.rotation.x = Math.atan(1 / Math.sqrt(2));
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // Grid
        let gridSize = 40;
        let gridHelper;
        let grid = [];

        function createGrid(size) {
            if (gridHelper) scene.remove(gridHelper);
            gridHelper = new THREE.GridHelper(size, size, 0x333333, 0x333333);
            gridHelper.position.set(size / 2 - 0.5, 0, size / 2 - 0.5);
            scene.add(gridHelper);
            grid = Array.from({ length: size }, () => Array(size).fill(null));
        }

        // Base Building class
        class Building {
            constructor(x, z, w, d, maxHP, modelPath) {
                this.x = x;
                this.z = z;
                this.w = w;
                this.d = d;
                this.maxHP = maxHP;
                this.currentHP = maxHP;
                this.modelPath = modelPath;
                this.mesh = null;
                this.healthBar = null;
                this.box = null;
                this.loadModel();
            }

            loadModel() {
                const loader = new THREE.GLTFLoader();
                loader.load(this.modelPath, (gltf) => {
                    this.mesh = gltf.scene;
                    this.mesh.position.set(this.x + this.w / 2, 0, this.z + this.d / 2);
                    scene.add(this.mesh);
                    this.mesh.traverse(child => {
                        if (child.isMesh) {
                            child.material = child.material.clone();
                        }
                    });
                    this.box = new THREE.Box3().setFromObject(this.mesh);
                    this.updateModel();
                }, undefined, (error) => {
                    console.error(`Failed to load model ${this.modelPath}:`, error);
                    this.mesh = new THREE.Mesh(
                        new THREE.BoxGeometry(this.w, this.d, 1),
                        new THREE.MeshLambertMaterial({ color: 0xff0000 })
                    );
                    this.mesh.position.set(this.x + this.w / 2, 0.5, this.z + this.d / 2);
                    scene.add(this.mesh);
                    this.box = new THREE.Box3().setFromObject(this.mesh);
                });
            }

            updateModel() {
                if (!this.mesh) return;
                const hpPercent = this.currentHP / this.maxHP;
                const color = hpPercent > 0.6 ? 0xffffff : hpPercent > 0.3 ? 0xffaa00 : 0xff0000;
                this.mesh.traverse(child => {
                    if (child.isMesh) {
                        child.material.color.setHex(color);
                    }
                });
            }

            updateTransparency(playerPos) {
                const playerBehind = playerPos.z > this.z + this.d;
                if (this.mesh) {
                    this.mesh.traverse(child => {
                        if (child.isMesh) {
                            child.material.opacity = playerBehind ? 0.5 : 1;
                            child.material.transparent = true;
                        }
                    });
                }
            }
        }

        // Building subclasses
        class Building_1_1 extends Building {
            constructor(x, z) {
                super(x, z, 1, 1, 3, 'models/Building_1_1.glb');
            }
        }

        class House_1_1 extends Building {
            constructor(x, z) {
                super(x, z, 1, 1, 3, 'models/house_1_1.glb');
            }
        }

        class House_2_2 extends Building {
            constructor(x, z) {
                super(x, z, 2, 2, 12, 'models/house_2_2.glb');
            }
        }

        class Shop_2_2 extends Building {
            constructor(x, z) {
                super(x, z, 2, 2, 12, 'models/shop_2_2.glb');
            }
        }

        class Tower_2_2 extends Building {
            constructor(x, z) {
                super(x, z, 2, 2, 12, 'models/tower_2_2.glb');
            }
        }

        class Building_4_2 extends Building {
            constructor(x, z) {
                super(x, z, 4, 2, 24, 'models/building_4_2.glb');
            }
        }

        let buildings = [];

        function generateBuildings(numBuildings, size) {
            buildings.forEach(b => {
                if (b.mesh) scene.remove(b.mesh);
                if (b.healthBar) scene.remove(b.healthBar);
            });
            buildings = [];
            createGrid(size);

            const buildingTypes = [
                { type: Building_1_1, size: [1, 1] },
                { type: House_1_1, size: [1, 1] },
                { type: House_2_2, size: [2, 2] },
                { type: Shop_2_2, size: [2, 2] },
                { type: Tower_2_2, size: [2, 2] },
                { type: Building_4_2, size: [4, 2] }
            ];

            let attempts = 0;
            while (buildings.length < numBuildings && attempts < 10000) {
                const buildingType = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                const [w, d] = buildingType.size;
                const x = Math.floor(Math.random() * (size - w));
                const z = Math.floor(Math.random() * (size - d));
                let free = true;
                for (let i = z; i < z + d && i < size; i++) {
                    for (let j = x; j < x + w && j < size; j++) {
                        if (grid[i][j]) free = false;
                    }
                }
                if (free) {
                    const building = new buildingType.type(x, z);
                    buildings.push(building);
                    for (let i = z; i < z + d; i++) {
                        for (let j = x; j < x + w; j++) {
                            grid[i][j] = building;
                        }
                    }
                }
                attempts++;
            }
        }

        // Player class
        class Player {
            constructor() {
                this.x = 0;
                this.z = 0;
                this.speed = 5;
                this.direction = new THREE.Vector3(0, 0, 0);
                this.lastDirection = new THREE.Vector3(1, 0, 0);
                this.mixer = null;
                this.actions = {};
                this.currentAction = null;
                this.mesh = null;
                this.loadModel();
            }

            loadModel() {
                const loader = new THREE.GLTFLoader();
                loader.load('models/char_action.glb', (gltf) => {
                    this.mesh = gltf.scene;
                    this.mesh.position.set(this.x, 0, this.z);
                    scene.add(this.mesh);
                    this.mixer = new THREE.AnimationMixer(this.mesh);
                    gltf.animations.forEach((clip) => {
                        const action = this.mixer.clipAction(clip);
                        this.actions[clip.name.toLowerCase()] = action;
                    });
                    this.setAction('idle');
                }, undefined, (error) => {
                    console.error('Failed to load player model:', error);
                    this.mesh = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.3, 1, 16),
                        new THREE.MeshLambertMaterial({ color: 0x0000ff })
                    );
                    this.mesh.position.set(this.x, 0.5, this.z);
                    scene.add(this.mesh);
                });
            }

            setAction(actionName) {
                if (this.currentAction) {
                    this.currentAction.stop();
                }
                this.currentAction = this.actions[actionName];
                if (this.currentAction) {
                    this.currentAction.play();
                }
            }

            playPunch() {
                if (this.actions['punch']) {
                    this.actions['punch'].reset().play();
                    this.actions['punch'].clampWhenFinished = true;
                    this.actions['punch'].loop = THREE.LoopOnce;
                }
            }

            update(delta) {
                const moveDir = new THREE.Vector3(this.direction.x, 0, this.direction.z).normalize();
                const isoX = (moveDir.x - moveDir.z) * 0.7071;
                const isoZ = (moveDir.x + moveDir.z) * 0.7071;

                const dx = isoX * this.speed * delta;
                const dz = isoZ * this.speed * delta;

                const newX = Math.max(0, Math.min(gridSize - 0.5, this.x + dx));
                const newZ = Math.max(0, Math.min(gridSize - 0.5, this.z + dz));

                if (this.canMove(newX, this.z)) this.x = newX;
                if (this.canMove(this.x, newZ)) this.z = newZ;

                // Only update mesh position and rotation if mesh is loaded
                if (this.mesh) {
                    this.mesh.position.set(this.x, 0, this.z);
                    if (this.direction.length() > 0) {
                        this.lastDirection.set(isoX, 0, isoZ).normalize();
                        const angle = Math.atan2(this.lastDirection.z, this.lastDirection.x) - Math.PI / 2;
                        this.mesh.rotation.y = angle;
                    }
                }

                // Update animations only if mixer is initialized
                if (this.mixer) {
                    this.mixer.update(delta);
                }
                if (!this.currentAction || !this.currentAction.isRunning() || this.currentAction !== this.actions['punch']) {
                    if (this.direction.length() > 0) {
                        if (this.currentAction !== this.actions['walk']) {
                            this.setAction('walk');
                        }
                    } else {
                        if (this.currentAction !== this.actions['idle']) {
                            this.setAction('idle');
                        }
                    }
                }
            }

            canMove(x, z) {
                const playerBox = new THREE.Box3(
                    new THREE.Vector3(x - 0.25, 0, z - 0.25),
                    new THREE.Vector3(x + 0.25, 1, z + 0.25)
                );
                return !buildings.some(b => b.box && playerBox.intersectsBox(b.box));
            }
        }

        let player = new Player();

        // Game state
        let score = 0;
        let time = 60;
        let gameOver = false;
        let canHit = true;
        const scoreElement = document.getElementById('score');
        const timeElement = document.getElementById('time');

        // Keyboard controls
        const pressedKeys = new Set();
        document.addEventListener('keydown', (e) => {
            if (gameOver) return;
            pressedKeys.add(e.key.toLowerCase());
            if (e.key === ' ' && canHit) {
                player.playPunch();
                hitBuilding();
                canHit = false;
            }
        });
        document.addEventListener('keyup', (e) => {
            pressedKeys.delete(e.key.toLowerCase());
            if (e.key === ' ') canHit = true;
        });

        function updatePlayerDirection() {
            player.direction.set(0, 0, 0);
            if (pressedKeys.has('w') || pressedKeys.has('arrowup')) player.direction.x = -1;
            if (pressedKeys.has('s') || pressedKeys.has('arrowdown')) player.direction.x = 1;
            if (pressedKeys.has('a') || pressedKeys.has('arrowleft')) player.direction.z = 1;
            if (pressedKeys.has('d') || pressedKeys.has('arrowright')) player.direction.z = -1;
            if (player.direction.length() > 0) player.direction.normalize();
        }

        // Hit building with proper removal
        function hitBuilding() {
            const raycaster = new THREE.Raycaster();
            const playerPos = this.mesh ? this.mesh.position : new THREE.Vector3(this.x, 0, this.z);
            raycaster.set(playerPos, player.lastDirection);
            const intersects = raycaster.intersectObjects(buildings.map(b => b.mesh).filter(m => m));
            if (intersects.length > 0) {
                const intersect = intersects[0];
                const building = buildings.find(b => b.mesh === intersect.object);
                if (building) {
                    const distanceToBuilding = building.box.distanceToPoint(playerPos);
                    if (distanceToBuilding <= 1) {
                        building.currentHP -= 1;
                        score += 1;
                        scoreElement.textContent = `Score: ${score}`;

                        if (building.currentHP <= 0) {
                            if (building.mesh) {
                                scene.remove(building.mesh);
                                building.mesh = null;
                            }
                            if (building.healthBar) {
                                scene.remove(building.healthBar);
                                building.healthBar = null;
                            }
                            for (let i = building.z; i < building.z + building.d; i++) {
                                for (let j = building.x; j < building.x + building.w; j++) {
                                    grid[i][j] = null;
                                }
                            }
                            buildings = buildings.filter(b => b !== building);
                        } else {
                            building.updateModel();

                            if (!building.healthBar && building.box) {
                                const canvas = document.createElement('canvas');
                                canvas.width = 100;
                                canvas.height = 20;
                                building.healthCanvas = canvas;
                                const texture = new THREE.CanvasTexture(canvas);
                                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                                building.healthBar = new THREE.Sprite(spriteMaterial);
                                building.healthBar.position.set(
                                    building.mesh.position.x,
                                    building.box.max.y + 0.5,
                                    building.mesh.position.z
                                );
                                building.healthBar.scale.set(2, 0.4, 1);
                                scene.add(building.healthBar);
                            }
                            if (building.healthCanvas) {
                                const ctx = building.healthCanvas.getContext('2d');
                                ctx.clearRect(0, 0, 100, 20);
                                ctx.fillStyle = 'red';
                                ctx.fillRect(0, 0, 100, 20);
                                const healthWidth = 100 * (building.currentHP / building.maxHP);
                                ctx.fillStyle = 'green';
                                ctx.fillRect(0, 0, healthWidth, 20);
                                building.healthBar.material.map.needsUpdate = true;
                            }
                        }
                    }
                }
            }
        }

        // UI controls
        document.getElementById('regenerate').addEventListener('click', () => {
            const newGridSize = parseInt(document.getElementById('mapSize').value);
            const newNumBuildings = parseInt(document.getElementById('numBuildings').value);
            gridSize = Math.min(Math.max(newGridSize, 10), 100);
            generateBuildings(Math.min(Math.max(newNumBuildings, 10), 100), gridSize);
            player.x = 0;
            player.z = 0;
            if (player.mesh) player.mesh.position.set(0, 0, 0);
            score = 0;
            time = 60;
            gameOver = false;
            scoreElement.textContent = `Score: ${score}`;
            timeElement.textContent = `Time: ${Math.ceil(time)}`;
        });

        // Camera controls
        const camXInput = document.getElementById('camX');
        const camYInput = document.getElementById('camY');
        const camZInput = document.getElementById('camZ');
        function updateCamera() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
        }
        camXInput.addEventListener('input', updateCamera);
        camYInput.addEventListener('input', updateCamera);
        camZInput.addEventListener('input', updateCamera);

        // Game loop
        let lastTime = performance.now();
        function animate() {
            requestAnimationFrame(animate);
            if (!gameOver) {
                const currentTime = performance.now();
                const delta = (currentTime - lastTime) / 1000;
                lastTime = currentTime;

                updatePlayerDirection();
                player.update(delta);

                const camOffsetX = parseInt(camXInput.value);
                const camOffsetY = parseInt(camYInput.value);
                const camOffsetZ = parseInt(camZInput.value);
                const playerPos = player.mesh ? player.mesh.position : new THREE.Vector3(player.x, 0, player.z);
                camera.position.set(playerPos.x + camOffsetX + 25, camOffsetY, playerPos.z + camOffsetZ + 25);
                camera.lookAt(playerPos.x, 0, playerPos.z);

                buildings.forEach(building => building.updateTransparency(playerPos));

                time -= delta;
                if (time <= 0) {
                    gameOver = true;
                    time = 0;
                    alert(`Game Over! Final Score: ${score}`);
                }
                timeElement.textContent = `Time: ${Math.ceil(time)}`;
            }
            renderer.render(scene, camera);
        }

        // Initial setup
        createGrid(gridSize);
        generateBuildings(20, gridSize);
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            camera.left = frustumSize * width / height / -2;
            camera.right = frustumSize * width / height / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });
    </script>
</body>
</html>